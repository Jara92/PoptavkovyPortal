<?php

namespace App\Tests\Unit\Security\Voter;

use App\Entity\Company;
use App\Entity\Inquiry\Inquiry;
use App\Entity\Person;
use App\Entity\User;
use App\Enum\Entity\InquiryState;
use App\Enum\Entity\InquiryType;
use App\Enum\Entity\UserRole;
use App\Enum\Entity\UserType;
use App\Security\UserSecurity;
use App\Security\Voter\InquiryVoter;
use PHPUnit\Framework\TestCase;
use ReflectionMethod;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;

class InquiryVoterTest extends TestCase
{
    private InquiryVoter $voter;

    private UserSecurity $security;

    public function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->voter = new InquiryVoter();
    }

    private function callPrivateMethod(object $target, string $method, array $params): mixed
    {
        $method = new ReflectionMethod($target, $method);

        // Invoke the method
        return $method->invokeArgs($target, $params);
    }

    private function getInquiry1()
    {
        return (new Inquiry())->setId(1)->setType(InquiryType::COMPANY)->setState(InquiryState::STATE_NEW);
    }

    private function getSecurity(?User $user, array $roles): UserSecurity
    {
        $isLoggedIn = $user !== null;

        $token = $this->createStub(TokenInterface::class);
        $token->method("getUser")->willReturn($user);

        $security = $this->createStub(UserSecurity::class);
        $security->method("getUser")->willReturn($user);
        $security->method("isLoggedIn")->willReturn($isLoggedIn);
        $security->method("getToken")->willReturn($token);
        $security->method("isGranted")->will(
            $this->returnCallback(function (UserRole $role) use ($roles) {
                return in_array($role, $roles);
            })
        );

        return $security;
    }

    private function getSecurityForUnsigned(): UserSecurity
    {
        $user = null;
        $roles = [UserRole::USER];

        return $this->getSecurity($user, $roles);
    }

    private function getSecurityForSignedPersonUser(): UserSecurity
    {
        $user = (new User())->setId(1)->setEmail("user@firma.cz")->setType(UserType::PERSON)
            ->setPerson((new Person())->setId(1)->setName("Pepa")->setSurname("NovÃ¡k"));

        $roles = [UserRole::USER, UserRole::INQUIRING, UserRole::VERIFIED];

        return $this->getSecurity($user, $roles);
    }

    private function getSecurityForSignedCompanyUser(): UserSecurity
    {
        $user = (new User())->setId(3)->setEmail("user@firma.cz")->setType(UserType::COMPANY)
            ->setCompany((new Company())->setId(1)->setName("Firma")->setIdentificationNumber("123456789"));

        $roles = [UserRole::USER, UserRole::INQUIRING, UserRole::VERIFIED, UserRole::SUPPLIER];

        return $this->getSecurity($user, $roles);
    }

    private function getSecurityForSuperAdmin(): UserSecurity
    {
        $user = (new User())->setId(2)->setEmail("user@firma.cz")->setType(UserType::COMPANY)
            ->setPerson((new Person())->setId(1)->setName("Super")->setSurname("Admin"));

        $roles = [UserRole::USER, UserRole::VERIFIED, UserRole::INQUIRING, UserRole::SUPPLIER, UserRole::ADMIN, UserRole::SUPER_ADMIN];

        return $this->getSecurity($user, $roles);
    }

    /**
     * NOTE: these all tests call "voteOnAttribute" method but they are actually testing a method given as parameter.
     */

    /**
     * @covers \App\Security\Voter\InquiryVoter::canCreate
     */
    public function testCreate()
    {
        $security = $this->getSecurityForUnsigned();
        $this->voter->setSecurity($security);
        $this->assertTrue($this->callPrivateMethod($this->voter, "voteOnAttribute", ["create", null, $security->getToken()]));
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canCreate
     */
    public function testCreateSuperAdmin()
    {
        // For now its same as testCreate
        $security = $this->getSecurityForSuperAdmin();
        $this->voter->setSecurity($security);
        $this->assertTrue($this->callPrivateMethod($this->voter, "voteOnAttribute", ["create", null, $security->getToken()]));
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canDelete
     */
    public function testDelete()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1();

        $this->assertFalse($this->callPrivateMethod($this->voter, "voteOnAttribute", ["delete", $inquiry, $security->getToken()]));
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canDelete
     */
    public function testDeleteNullInquiry()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        // The inquiry must be filled so we expect TypeError expection
        $this->expectException(\TypeError::class);

        $this->callPrivateMethod($this->voter, "voteOnAttribute", ["delete", null, $security->getToken()]);
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canDelete
     */
    public function testDeleteSuperAdmin()
    {
        $security = $this->getSecurityForSuperAdmin();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1();

        // Super admin can delete an inquiry
        $this->assertTrue($this->callPrivateMethod($this->voter, "voteOnAttribute", ["delete", $inquiry, $security->getToken()]));
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canView
     */
    public function testViewUnsigned()
    {
        $security = $this->getSecurityForUnsigned();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1();

        // Create a map for inqury states and expected results
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => true,
            InquiryState::STATE_ARCHIVED->value => true,
            InquiryState::STATE_FINISHED->value => true,

            InquiryState::STATE_NEW->value => false,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Super admin can delete an inquiry
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["view", $inquiry, $security->getToken()]));
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canView
     */
    public function testViewSignedButNotAuthor()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1();

        // Create a map for inqury states and expected results
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => true,
            InquiryState::STATE_ARCHIVED->value => true,
            InquiryState::STATE_FINISHED->value => true,

            InquiryState::STATE_NEW->value => false,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["view", $inquiry, $security->getToken()]));
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canView
     */
    public function testViewSignedAuthor()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1()->setAuthor($security->getUser());

        // Create a map for inqury states and expected results
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => true,
            InquiryState::STATE_ARCHIVED->value => true,
            InquiryState::STATE_FINISHED->value => true,

            InquiryState::STATE_NEW->value => true,
            InquiryState::STATE_PROCESSING->value => true,
            InquiryState::STATE_DELETED->value => true,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["view", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canView
     */
    public function testViewSuperAdmin()
    {
        $security = $this->getSecurityForSuperAdmin();
        $this->voter->setSecurity($security);

        $author = (new User())->setId(2)->setEmail("user@seznam.cz")
            ->setPerson((new Person())->setId(2)->setName("Pavel")->setSurname("Novak"));

        $inquiry = $this->getInquiry1()->setAuthor($author);

        // Check each state result
        foreach (InquiryState::cases() as $state) {
            $inquiry->setState($state);

            // Super admin we expect true always
            $this->assertTrue($this->callPrivateMethod($this->voter, "voteOnAttribute", ["view", $inquiry, $security->getToken()]),
                "Failed equals assert for $state->value. Expected: true");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canEdit
     */
    public function testCanEditSignedButNotAuthor()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        $author = (new User())->setId(2)->setEmail("user@seznam.cz")
            ->setPerson((new Person())->setId(2)->setName("Pavel")->setSurname("Novak"));

        $inquiry = $this->getInquiry1()->setAuthor($author);

        // Check each state result
        foreach (InquiryState::cases() as $state) {
            $inquiry->setState($state);

            // Should be false because I cannot edit other users inquiries
            $this->assertFalse($this->callPrivateMethod($this->voter, "voteOnAttribute", ["edit", $inquiry, $security->getToken()]));
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canEdit
     */
    public function testCanEditSignedAuthor()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1()->setAuthor($security->getUser());

        // Create a map for inqury states and expected results
        // Only new inquiries can be edited by its author because it has not been processed and checked yet.
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => false,
            InquiryState::STATE_ARCHIVED->value => false,
            InquiryState::STATE_FINISHED->value => false,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => true,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["edit", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canEdit
     */
    public function testCanEdit()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1()->setAuthor($security->getUser());

        // Create a map for inqury states and expected results
        // Only new inquiries can be edited by its author because it has not been processed and checked yet.
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => false,
            InquiryState::STATE_ARCHIVED->value => false,
            InquiryState::STATE_FINISHED->value => false,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => true,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["edit", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canReact
     */
    public function testCanReactUnsigned()
    {
        $security = $this->getSecurityForUnsigned();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1()->setAuthor(null);

        // Create a map for inqury states and expected results
        // Unsigned user cannot react at all.
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => false,
            InquiryState::STATE_ARCHIVED->value => false,
            InquiryState::STATE_FINISHED->value => false,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => false,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["react", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canReact
     */
    public function testCanReactSignedButNotSupplier()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1()->setAuthor(null);

        // Create a map for inqury states and expected results
        // Non suppliers cannot react at all
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => false,
            InquiryState::STATE_ARCHIVED->value => false,
            InquiryState::STATE_FINISHED->value => false,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => false,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["react", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canReact
     */
    public function testCanReactSignedSupplier()
    {
        $security = $this->getSecurityForSignedCompanyUser();
        $this->voter->setSecurity($security);

        $author = (new User())->setId(2)->setEmail("user@seznam.cz")
            ->setPerson((new Person())->setId(2)->setName("Pavel")->setSurname("Novak"));

        $inquiry = $this->getInquiry1()->setAuthor($author);

        // Create a map for inqury states and expected results
        // Supplier can respond to all public inquiry states in voter. But in real the user can respond only to active inquiry.
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => true,
            InquiryState::STATE_ARCHIVED->value => true,
            InquiryState::STATE_FINISHED->value => true,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => false,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["react", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canReact
     */
    public function testCanReactSignedSupplierIsAuthor()
    {
        $security = $this->getSecurityForSignedCompanyUser();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1()->setAuthor($security->getUser());

        // Create a map for inqury states and expected results
        // Supplier cannot respond to his own inquiries.
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => false,
            InquiryState::STATE_ARCHIVED->value => false,
            InquiryState::STATE_FINISHED->value => false,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => false,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["react", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canViewAttachments
     */
    public function testCanViewAttachmentsUnsigned()
    {
        $security = $this->getSecurityForUnsigned();
        $this->voter->setSecurity($security);

        $author = (new User())->setId(2)->setEmail("user@seznam.cz")
            ->setPerson((new Person())->setId(2)->setName("Pavel")->setSurname("Novak"));

        $inquiry = $this->getInquiry1()->setAuthor($author);

        // Create a map for inqury states and expected results
        // Unsigned user cannot view attachments at all
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => false,
            InquiryState::STATE_ARCHIVED->value => false,
            InquiryState::STATE_FINISHED->value => false,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => false,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["view_attachments", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canViewAttachments
     */
    public function testCanViewAttachmentsSignedNonSupplier()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        $author = (new User())->setId(2)->setEmail("user@seznam.cz")
            ->setPerson((new Person())->setId(2)->setName("Pavel")->setSurname("Novak"));

        $inquiry = $this->getInquiry1()->setAuthor($author);

        // Create a map for inqury states and expected results
        // Signed non-supplier user cannot view attachments at all
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => false,
            InquiryState::STATE_ARCHIVED->value => false,
            InquiryState::STATE_FINISHED->value => false,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => false,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["view_attachments", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canViewAttachments
     */
    public function testCanViewAttachmentsSignedSupplier()
    {
        $security = $this->getSecurityForSignedCompanyUser();
        $this->voter->setSecurity($security);

        $author = (new User())->setId(2)->setEmail("user@seznam.cz")
            ->setPerson((new Person())->setId(2)->setName("Pavel")->setSurname("Novak"));

        $inquiry = $this->getInquiry1()->setAuthor($author);

        // Create a map for inqury states and expected results
        // Signed supplier can view attachments
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => true,
            InquiryState::STATE_ARCHIVED->value => true,
            InquiryState::STATE_FINISHED->value => true,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => false,
            InquiryState::STATE_PROCESSING->value => false,
            InquiryState::STATE_DELETED->value => false,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["view_attachments", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }

    /**
     * @covers \App\Security\Voter\InquiryVoter::canViewAttachments
     */
    public function testCanViewAttachmentsSignedAuthor()
    {
        $security = $this->getSecurityForSignedPersonUser();
        $this->voter->setSecurity($security);

        $inquiry = $this->getInquiry1()->setAuthor($security->getUser());

        // Create a map for inquiry states and expected results
        // Author can view attachments anytime
        $statesAndExpectedResult = [
            InquiryState::STATE_ACTIVE->value => true,
            InquiryState::STATE_ARCHIVED->value => true,
            InquiryState::STATE_FINISHED->value => true,

            // Signed user can edit only his NEW inquiries.
            InquiryState::STATE_NEW->value => true,
            InquiryState::STATE_PROCESSING->value => true,
            InquiryState::STATE_DELETED->value => true,
        ];

        // Check each state result
        foreach ($statesAndExpectedResult as $state => $value) {
            $inquiry->setState(InquiryState::from($state));

            // Check result for current state
            $this->assertEquals($value, $this->callPrivateMethod($this->voter, "voteOnAttribute", ["view_attachments", $inquiry, $security->getToken()]),
                "Failed equals assert for $state. Expected: " . ($value) ? "true" : "false");
        }
    }
}